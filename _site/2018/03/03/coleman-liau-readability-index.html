<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Coleman-Liau Readability Index | F1LT3R</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Coleman-Liau Readability Index" />
<meta name="author" content="Alistair MacDonald" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="During a spell of frequent writing, I tested a multitude of software tools promising to make my writing better." />
<meta property="og:description" content="During a spell of frequent writing, I tested a multitude of software tools promising to make my writing better." />
<link rel="canonical" href="http://localhost:4000/2018/03/03/coleman-liau-readability-index.html" />
<meta property="og:url" content="http://localhost:4000/2018/03/03/coleman-liau-readability-index.html" />
<meta property="og:site_name" content="F1LT3R" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-03T17:38:51-05:00" />
<script type="application/ld+json">
{"description":"During a spell of frequent writing, I tested a multitude of software tools promising to make my writing better.","author":{"@type":"Person","name":"Alistair MacDonald"},"@type":"BlogPosting","url":"http://localhost:4000/2018/03/03/coleman-liau-readability-index.html","headline":"Coleman-Liau Readability Index","dateModified":"2018-03-03T17:38:51-05:00","datePublished":"2018-03-03T17:38:51-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/03/03/coleman-liau-readability-index.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="F1LT3R" /><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3/build/web/hack.css">
</head>
<body class="">
    <!-- <video autoplay muted loop id="myVideo">
        <source src="https://i.imgur.com/lBSSjpo.mp4" type="video/mp4">
     </video> --><header class="site-header wide" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">F1LT3R</a>
    <!-- <div class="ident">
      <img class="logo" src="/img/site/f1lt3r-logo.svg"/>
    </div>
     -->

    <!-- <div id="search-container">
        <input type="text" id="search-input" placeholder="search...">
        <ul id="results-container"></ul>
    </div>
    <script src="/js/search-script.js" type="text/javascript"></script>
    <script>
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: '/search.json'
    })
    </script> --><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/bio/">Bio</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="feature-image"> 
    <div class="img" style="background-image: url('https://images.unsplash.com/photo-1521714161819-15534968fc5f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1650&q=80'); width:100%;"></div>
  </div> 

  <header class="post-header">
    <!-- <img class="feature-image" src="https://images.unsplash.com/photo-1521714161819-15534968fc5f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1650&q=80"/> -->
    <h1 class="post-title p-name" itemprop="name headline">Coleman-Liau Readability Index</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-03-03T17:38:51-05:00" itemprop="datePublished">Mar 3, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>During a spell of frequent writing, I tested a multitude of software tools promising to make my writing better.</p>

<p>The shortlist:</p>

<ul>
  <li>Grammarly - Grammar, thesaurus features</li>
  <li>Readable.io - Readability Scores</li>
  <li>Scrivener - Organized Writing (Word on Steroids)</li>
  <li>Ulysses - A distraction free Scrivener with Markdown Syntax</li>
</ul>

<p>All of these tools have different features to offer. All of these tools are great in their own way. But Readable.io was interesting because it provided statistics. The statistics in Readable.io help guide the writer, showing what grade level a reader needs to be to understand the writing.</p>

<h2 id="enter-coleman-liau">Enter Coleman-Liau</h2>

<p>I hooked up the Readable.io API to Node.js to experiment with different portions of text.</p>

<p>You can check out the quick Readable.io Node.js repo I created here on Github: <a href="https://github.com/F1LT3R/readable.io-api-example">https://github.com/F1LT3R/readable.io-api-example</a></p>

<p>I kept firing text at the API and seeing what scores I got back. I followed up by reading what each of the scores meant in Wikipedia, and on the Readable.io blog.</p>

<p>From the text I used, I felt the Coleman-Liau Index was producing the most consistent results:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"The quick fox jumped over the lazy dog."
// Grade: 3.3
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"The quick, sly omnivorous mammal jumped energetically over the sullen, sleepy canine."
// Grade: 16.5
</code></pre></div></div>

<p>The levels that are returned by Readable.io represent the educational grade a student would need to comfortably read the text without slowing down.</p>

<p>Because of the simplicity in how the The Coleman-Luau Index is calculated, it appears to have the broadest application to all types of writing, and all kinds of readers.</p>

<p>Other reading level indexes use more complicated methods, like counting syllables, which makes them more difficult to calculate with a computer program, and generally more difficult to use without a computer.</p>

<h2 id="according-to-wikipedia">According to Wikipedia</h2>

<p>I became interested in how the Coleman-Liau index was being calculated and so I spent some time reading this Wikipedia article: <a href="https://en.wikipedia.org/wiki/Coleman%E2%80%93Liau_index">Coleman-Liau index</a>. The article provided a formula to calculate the Coleman Liau Index and a text sample for demonstration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Existing computer programs that measure readability are based largely upon subroutines which estimate number of syllables, usually by counting vowels. The shortcoming in estimating syllables is that it necessitates keypunching the prose into the computer. There is no need to estimate syllables since word length in letters is a better predictor of readability than word length in syllables. Therefore, a new readability formula was computed that has for its predictors letters per 100 words and sentences per 100 words. Both predictors can be counted by an optical scanning device, and thus the formula makes it economically feasible for an organization such as the U.S. Office of Education to calibrate the readability of all textbooks for the public school system."
// Grade 14.5
</code></pre></div></div>

<p>The text above is an excerpt from the original paper by Coleman Liau called: <a href="http://dx.doi.org/10.1037/h0076540">A Computer Readability Formula Designed for Machine Scoring.</a></p>

<p>The algorithm goes something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L = Letters ÷ Words × 100 = 639 ÷ 119 × 100 ≈ 537  
S = Sentences ÷ Words × 100 = 5 ÷ 119 × 100 ≈ 4.20  
CLI = 0.0588 x 537 - 0.296 x 4.20 - 15.8 = 14.5
</code></pre></div></div>

<p>The algorithm can be broken down like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L = The average number of letters per 100 words
S = The average number of sentences per 100  words
Magic Number #1 =  0.0588
Magic Number #2 =  0.296
Magic Number #2 =  15.8
Reading Grade = (Magic Number #1 * L) - (Magic Number #2 - S) - Magic Number #3
</code></pre></div></div>

<p>There are several frustrating things about the explaination on Wikipedia:</p>

<ol>
  <li>Three magic numbers exist in the algorithm. What do they represent? Why do they make the algorithm work? It would be nice if the Wikipedia article explained the reason for the magic numbers.</li>
  <li>The Wikipedia article uses an approximation for the values of <code class="highlighter-rouge">L</code> and <code class="highlighter-rouge">S</code>, but does not point out that the <code class="highlighter-rouge">CLI</code>  is also an approximation. Running the  final line in a calculator gives me the following results: <code class="highlighter-rouge">0.0588 * 537 - 0.296 * 4.20 - 15.8 = 14.5324</code>.  Inconsistencies like this make it a little more difficult to know I was calculating correct results.</li>
  <li>The article does not tell you whether symbolic characters are counted. An example of this is the two periods in the abbreviated word <code class="highlighter-rouge">U.S.</code></li>
</ol>

<h2 id="is-readableio-wrong">Is Readable.io Wrong?</h2>

<p>What score does Readable.io give the sample text?</p>

<p>Answer: <code class="highlighter-rouge">14.0</code></p>

<p>Who is right? Readble.io or Wikipedia? After some digging around, I found Readable.io to have incorrect results. By deleting the period symbols from the sample text, Readable.io gives the Coleman-Liau score: <code class="highlighter-rouge">14.7</code>, much closer to Wikipedia’s result of <code class="highlighter-rouge">14.5</code>.</p>

<p>The inaccuracy here is largely to do with the way that the Readiable.io is breaking down sentences. Let’s compare how a few different tools calculate this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The way I read things...
sentences = {
  1: "Existing computer programs that measure readability are based largely upon subroutines which estimate number of syllables, usually by counting vowels.",
  2: "The shortcoming in estimating syllables is that it necessitates keypunching the prose into the computer."
  3: "There is no need to estimate syllables since word length in letters is a better predictor of readability than word length in syllables."
  4: "Therefore, a new readability formula was computed that has for its predictors letters per 100 words and sentences per 100 words."
  5: "Both predictors can be counted by an optical scanning device, and thus the formula makes it economically feasible for an organization such as the U.S. Office of Education to calibrate the readability of all textbooks for the public school system."
}  
</code></pre></div></div>

<ul>
  <li>Actual sentences: 5</li>
  <li>Readable.io sentence count: 7</li>
  <li>Ulysses sentence count: 6</li>
</ul>

<p>I believe that Ulysses is counting the word “U.S.” as the break of a sentence.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The way Ulyses reads things...
sentences = {
  ...
  5: "Both predictors can be counted by an optical scanning device, and thus the formula makes it economically feasible for an organization such as the U.S." // &lt;-- BREAK
  6: "Office of Education to calibrate the readability of all textbooks for the public school system."
}  
</code></pre></div></div>

<p>Even more alarming, Readable.io measures the following text as having three sentences:</p>

<blockquote>
  <p>“Everybody loves the U.S. Office of Education.”</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The way Readible.io reads things...
sentences = {
  ...
  5: "Both predictors can be counted by an optical scanning device, and thus the formula makes it economically feasible for an organization such as the U." // &lt;-- BREAK
  6: "S.", // &lt;-- BREAK
  7: "Office of Education to calibrate the readability of all textbooks for the public school system."
}  
</code></pre></div></div>

<p>Clearly the words: “Everybody loves the U.S. Office of Education”, is one sentence. But Readable.io is counting each period as a new sentence. Counting every period as a new sentence is how Readable.io is dropping the grade from <code class="highlighter-rouge">14.5</code> to <code class="highlighter-rouge">14.0</code>, because one long sentence is broken into three very short sentences. Voilà! It just became more readable! (I kid)</p>

<p>Based on my implementation of the Coleman Liau algorithm, I think Readble.io is counting all comma symbols as letters. When I run the algorithm this way I get a score of: <code class="highlighter-rouge">13.932319999999997</code>, which I suspect is being rounded up to <code class="highlighter-rouge">14.0</code> by Readible.io.</p>

<h3 id="where-do-sentences-end">Where Do Sentences End?</h3>

<p>The average reader can intuit where a sentence ends with ease. But to be fair to Readible.io and Ulyses, programming this level of compelx intuition is not easy.</p>

<p>When I try to think of how I would program for this, I want to throw my hands up and say: <em>‘It’s too complex for me to figure out. Perhaps we just use machine learning?’</em> And another part of me loves the challenge.</p>

<p>I tried for a couple of hours to come up with Regular Expressions that would satisfy the abbreviation use case. But I did not find a solution. I think it is likely that a solution to this problem would require a significantly complex knowledge of sentence structures.</p>

<p>Consider this paragraph:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>“Would you like to fly to St. Lucia?" Mr. Martin asked.  
”I’m not sure!" replied Lucy, "is it nice?"  
“St. Lucia is lovely, Lucy," said Mr. Martin, "especially St. Jame's Bay along Chapel St."  
“Then we shall go to Chapel St., St. Jame's Bay, St. Lucia Mr. Martin!", she said.  
And so they left the U.S.A. They departed immediately.
</code></pre></div></div>

<p>How would you program an algorithm to count the sentences in this text?</p>

<p>Readable.io counts this as twenty sentences and provides a Coleman-Liau index of <code class="highlighter-rouge">-3.3</code>! I count six sentences. And Grammarly gives me a score of 100, meaning there are no errors by their reconing. Even though I would never intentionally write in such a confusing way, I did use Grammarly to send this text to proof readers, so it is as legit as I can make it.</p>

<p>Titles like “Mr.” and “Mrs.” are easy to calculate, except where some spritely British lad says, “Thanks, Mr. I appreciate it!”.  Because the period at the end of  “Mr.” represents the end of a sentence not the title and name “Mr. I”. This is contrived, and not a proper sentence anyway, but you get the point: things get complex quickly.</p>

<p>A better example might be abbreviated Words like “U.S.A.” are also easy to calculate, except when they are at the end of a sentence. For example: “We love to party in the U.S.A. In the U.S.A. we love to party.”</p>

<p>I have always disliked when writers add two spaces to break every sentence, but for the sake a of decyphering English, that practice makes calculating the end of sentences much easier.</p>

<p>If I could re-invent the English language, I would make periods that demark sentences a different symbol than periods that demark titles and acronyms.</p>

<h2 id="the-original-white-paper">The Original White Paper</h2>

<p>I got hold of the original white-paper <a href="http://psycnet.apa.org/record/1975-22007-001">Non-Native English Speaker Readability Metric: Reading Speed and Comprehension</a>, to see if it could shed any light on the magic numbers used the algorithm.</p>

<p>After some help from my fabulous assistant who reads these kinds of things for a living, I came to understanding that the magic numbers are the result of calculating bodies of text against reading test results from some kind of human study. The numbers work as weights for average English text.</p>

<p>Seeing as this paper was written in the 1970’s and language is always changing, I would suppose that such a simplistic algorithm for grade level evaluation should be taken with a pinch of salt.</p>

<p>That being said, having such a simple algorithm does provide a way of comparing relative bodies of text with great ease; albeit with the caveat that minor inaccuracies will produce a little noise among the signal.</p>

<h2 id="my-implementation-of-the-coleman-liau-algorithm">My Implementation of The Coleman-Liau Algorithm</h2>

<p>I started building out an implementation of the Coleman-Liau index with ESNext in Node.js. I started by splitting a single string into sentences, and then sentences into words. But I found that it was easier to determine word endings by splitting the text into words first, and sentences later. This is because the space character <code class="highlighter-rouge">“ "</code> always represents the boundary of word. This methodology picks up various symbols along the way, but these seem easier to deal with at a word-level than a sentence level.</p>

<p>After running into the problem of the text: “The U.S. Office of Education”, I decided it was best to feed the sentences into the algorithm in an array of lines. If I want to come back at a later time with some magic way of splitting sentences, I can do that. But I had bigger fish to fry.</p>

<p>I wanted to know:</p>

<ul>
  <li>Exactly how the Wikipedia article writer got to a score of <code class="highlighter-rouge">14.5</code> from the sample text.</li>
  <li>If the Wikipedia algorithm was taken directly from the original white-paper or was an approximation.</li>
</ul>

<p>My implementation has the following architecture:</p>

<ul>
  <li>Pass an array of sentences to the routine</li>
  <li>Split the words at the space character “ “</li>
  <li>Clean all the words of dangling symbols like comma “,” and period “.”</li>
  <li>Count the number of letters</li>
  <li>Calculate L (The average number of letters per 100 words)</li>
  <li>Calculate S (The average number of sentences per 100 words)</li>
  <li>Calculate CLI (0.0588 * L - 0.296 * S - 15.8)</li>
</ul>

<p>Removing all symbols that were not letters of the alphabet from the words, I was able to count the exact same number of letters and words as the Wikipedia article.</p>

<p>Like the Wikipedia article, my algorithm produced:</p>

<ul>
  <li>A letter count of <code class="highlighter-rouge">639</code></li>
  <li>A word count of <code class="highlighter-rouge">119</code></li>
  <li>An L value of <code class="highlighter-rouge">536.9747899159663</code> or <code class="highlighter-rouge">537</code> rounded</li>
  <li>An S value of <code class="highlighter-rouge">4.201680672268908 </code> or <code class="highlighter-rouge">4.20</code> rounded</li>
</ul>

<p>Using unrounded S and L values, my algorithm produced a Coleman-Liau index of  <code class="highlighter-rouge">14.53042016806722</code>.</p>

<p>Following Wikipedia’s rounding methodology, my algorithm produces a Coleman-Liau index of <code class="highlighter-rouge">14.532399999999996</code>.</p>

<p>It is unclear why the article writer rounded the S and L values. Rounding does not appear to effect the value beyond two decimal points and so it seems like an insignificant step.</p>

<p>I have to wonder if the Wikipedia article writer intended to produce the exact value <code class="highlighter-rouge">14.5</code> using rounding. Perhaps the reason would be clear when programming the algorithm in a language that did not use double-precision floating-point numbers, as JavaScript does.</p>

<p>You can read more about the differences between numbers in different programming languages here: <a href="http://2ality.com/2012/04/number-encoding.html">How numbers are encoded in JavaScript</a> and <a href="http://www.exploringbinary.com/print-precision-of-dyadic-fractions-varies-by-language/">Print Precision of Dyadic Fractions Varies by Language</a>.</p>

<h3 id="my-code">My Code</h3>

<p>Here is the solution I came up with:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Remove spurious characters from word boundaries</span>
<span class="kd">const</span> <span class="nx">cleanWords</span> <span class="o">=</span> <span class="nx">words</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">cleanWords</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="nx">words</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">word</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">lastChar</span> <span class="o">=</span> <span class="nx">word</span><span class="p">[</span><span class="nx">word</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">// Get rid of periods, period.</span>
    <span class="nx">word</span> <span class="o">=</span> <span class="nx">word</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">\.</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">)</span>

    <span class="c1">// Remove commas, they mean nothing.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">lastChar</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">,</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">word</span> <span class="o">=</span> <span class="nx">word</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">word</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">cleanWords</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">cleanWords</span>
<span class="p">}</span>

<span class="c1">// Atomize a sentence into words</span>
<span class="kd">const</span> <span class="nx">splitWords</span> <span class="o">=</span> <span class="nx">sentences</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">wordList</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="nx">sentences</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">sentence</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">words</span> <span class="o">=</span> <span class="nx">sentence</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">wordList</span> <span class="o">=</span> <span class="nx">wordList</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">words</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">wordList</span>
<span class="p">}</span>

<span class="c1">// Count every letter (after cleaning words)</span>
<span class="kd">const</span> <span class="nx">countLetters</span> <span class="o">=</span> <span class="nx">words</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="nx">words</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">word</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">count</span> <span class="o">+=</span> <span class="nx">word</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>

<span class="c1">// Passsing in an array of sentences means that I do not</span>
<span class="c1">// have to figure out how to atomize titles and acronyms</span>
<span class="c1">// like U.S.A and Mr.</span>
<span class="kd">const</span> <span class="nx">colemanliau</span> <span class="o">=</span> <span class="nx">sentenceAry</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">rawWords</span> <span class="o">=</span> <span class="nx">splitWords</span><span class="p">(</span><span class="nx">sentenceAry</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">cleanWords</span> <span class="o">=</span> <span class="nx">cleanWords</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
  
  <span class="kd">const</span> <span class="nx">wordCount</span> <span class="o">=</span> <span class="nx">cleanWords</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">letterCount</span> <span class="o">=</span> <span class="nx">countLetters</span><span class="p">(</span><span class="nx">cleanWords</span><span class="p">)</span>
  
  <span class="kd">const</span> <span class="nx">L</span> <span class="o">=</span> <span class="p">(</span><span class="nx">letterCount</span> <span class="o">/</span> <span class="nx">wordCount</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
  <span class="kd">const</span> <span class="nx">S</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sentencesAry</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="nx">wordCount</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
  <span class="kd">const</span> <span class="nx">grade</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0588</span> <span class="o">*</span> <span class="nx">L</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.296</span> <span class="o">*</span> <span class="nx">S</span><span class="p">)</span> <span class="o">-</span> <span class="mf">15.8</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`L: </span><span class="p">${</span><span class="nx">L</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`S: </span><span class="p">${</span><span class="nx">S</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`GRADE: </span><span class="p">${</span><span class="nx">grade</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This can be used by passing in an array of sentences like so:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sentences</span> <span class="o">=</span> <span class="p">[</span>
  <span class="dl">'</span><span class="s1">Existing computer programs that measure readability are based largely upon subroutines which estimate number of syllables, usually by counting vowels.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">The shortcoming in estimating syllables is that it necessitates keypunching the prose into the computer.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">There is no need to estimate syllables since word length in letters is a better predictor of readability than word length in syllables.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">Therefore, a new readability formula was computed that has for its predictors letters per 100 words and sentences per 100 words.</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">Both predictors can be counted by an optical scanning device, and thus the formula makes it economically feasible for an organization such as the U.S. Office of Education to calibrate the readability of all textbooks for the public school system</span><span class="dl">'</span>
<span class="p">]</span>
 
<span class="nx">colemanliau</span><span class="p">(</span><span class="nx">sentences</span><span class="p">)</span>

<span class="c1">// L: 537</span>
<span class="c1">// S: 4.2</span>
<span class="c1">// GRADE: 14.532399999999996</span>
</code></pre></div></div>

<p>If you would like to try this code youself, you can get it here on Github: <a href="https://github.com/F1LT3R/coleman-liau-readability-index">https://github.com/F1LT3R/coleman-liau-readability-index</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>My biggest takeaway was that using acronyms and titles in text on Readable.io and Ulyses could considerably skew the readability score. Readability scores are more accurate on larger bodies of text due to the calculation errors of complex text in readability software.</p>

<p>You probably don’t want to take the readability of 3 paragraph email seriously.</p>

<p>The next biggest learning was just how prickly a software solution for calculating sentences was when containing acronyms and titles. I’m not saying it can’t be done well, I’m just saying there’s a big tradeoff conseration between the acuracy of the results and the difficulty of implementation.</p>

<p>That’s all folks.</p>


<div class="sign"><pre>       ___ _ _  ____________
 ___  | __/ | ||_   ___   _ \
/___/ | _|| | |__| | |_ \   /
      |_| |_|____|_||___/_|_\</pre></div><a class="u-url" href="/2018/03/03/coleman-liau-readability-index.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>
  
  <div class="wrapper">
    
    
    <div class="footer-col-wrapper">
      
      <div class="footer-col">
        <div class="avatar">
          <img src="/img/site/f1lt3r-avatar.jpg" />
        </div>
      </div>
       
      <div class="footer-col">
          <h2 class="footer-heading">F1LT3R</h2>
          <ul class="contact-list">
            <li class="p-name">Alistair MacDonald</li><li><a class="u-email" href="mailto:al@pwn.io">al@pwn.io</a></li></ul>
      </div>

      <div class="footer-col"><ul class="social-media-list"><li><a href="https://github.com/f1lt3r"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">f1lt3r</span></a></li><li><a href="https://instagram.com/f1lt3r"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg> <span class="username">f1lt3r</span></a></li><li><a href="https://www.linkedin.com/in/f1lt3r"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">f1lt3r</span></a></li><li><a href="https://www.twitter.com/F1LT3R_"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">F1LT3R_</span></a></li></ul>
</div>

      <div class="footer-col">
          <p>An engineering blog</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
